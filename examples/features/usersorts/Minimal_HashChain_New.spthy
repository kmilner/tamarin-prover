theory Minimal_HashChain_New begin

builtins: natural-numbers

functions: f: Nat Msg -> Msg [iterated]

// Chain setup phase
////////////////////

// Hash chain generation
rule Gen_Start:
    [ Fr(seed) ]
  --[ ChainKey(seed) ]->
    [ Gen(f(1:nat, seed)), Out(seed) ]

rule Gen_Step:
    [ Gen(f(x:nat, seed)) ]
  --[ ChainKey(f(x:nat, seed)) ]->
    [ Gen(f((x:nat + 1), seed)) ]

// At some point the sender decides to stop the hash-chain precomputation.
rule Gen_Stop:
    [ Gen(kZero) ]
  --[ ChainKey(kZero) ]->
    [ !Final(kZero) ]

// Key checking
///////////////

rule Check_Start0:
    [ In(f(x:nat, k)), Fr(loopId) ]
  --[ Start(loopId, f(x:nat, k)) ]->
    [ Loop(loopId, f((x:nat + 1), k), f(x:nat, k)) ]

rule Check_Start1:
    [ In(kOrig), Fr(loopId) ]
  --[ Start(loopId, kOrig) ]->
    [ Loop(loopId, f(1:nat, kOrig), kOrig) ]

rule Check_Step:
    [ Loop(loopId, f(x:nat, kOrig), kOrig) ]
  --[ Loop(loopId, f(x:nat, kOrig), kOrig) ]->
    [ Loop(loopId, f((x:nat + 1), kOrig), kOrig) ]

rule Check_Stop:
    [ Loop(loopId, kZero, kOrig), !Final(kZero) ]
  --[ Success(loopId, kOrig) ]->
    []

// Provable: restricts the search space
lemma Loop_Start [use_induction, reuse]:
  "All lid k kOrig #i.
    Loop(lid, k, kOrig) @ i ==>
    Ex #j. Start(lid, kOrig) @ j & j < i"

// Provable: restricts the search space
lemma Loop_Success_ord [use_induction, reuse]:
  "All lid k kOrig1 kOrig2 #i #j.
       Loop(lid, k, kOrig1) @ i
     & Success(lid, kOrig2) @ j
    ==>
     ( i < j )
  "

// Provable: If f(x:nat, k) is a key, k must also be a key.
lemma Chain_Key_end [use_induction, reuse]:
  "All x:nat k #i .
    ChainKey(f(x:nat, k)) @ i ==> Ex #j . ChainKey(k) @ j"

// Provable: A successful check implies that the key was a chain key.
lemma Success_chain:
  "All lid k #i.
    Success(lid, k) @ i ==>
    Ex #j. ChainKey(k) @ j"

end
