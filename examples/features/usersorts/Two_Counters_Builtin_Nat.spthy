theory Two_Counters_Builtin_Nat
begin

builtins: hashing, natural-numbers

rule Init_State:
    [ Fr(~ltk) ]
  -->
    [ !Ltk($A, $B, ~ltk)
    , Counter_C($A, $B, ~ltk, 0:nat)
    , Counter_S($B, $A, ~ltk, 0:nat) ]

rule Reveal_Ltk:
    [ !Ltk(A, B, ltk) ]
  --[ LtkReveal(ltk) ]->
    [ Out(ltk) ]

rule Client_1:
    [ Counter_C($C, $S, ~ltk, y:nat)
    , !Ltk($C, $S, ~ltk) ]
  --[ Req($C, $S, ~ltk, y:nat) ]->
    [ Counter_C($C, $S, ~ltk, (1 + y:nat))
    , Out(h(<$C, $S, ~ltk, y:nat>))
    ]

rule Server_1:
    [ Counter_S($S, $C, ~ltk, y:nat)
    , !Ltk($C, $S, ~ltk) 
    , In(h(<$C, $S, ~ltk, y:nat>))
    ]
  --[ Auth($C, $S, ~ltk, y:nat) ]->
    [ Counter_S($S, $C, ~ltk, (1 + y:nat))
    ]

lemma Lemma1:
    exists-trace
    "
    Ex A B ltk #i #j.
        Auth(A, B, ltk, 1:nat) @ #i
        & Req(A, B, ltk, 1:nat) @ #j 
        & j < i
    "

lemma Lemma2:
    "
    All A B ltk y #i. Auth(A, B, ltk, y) @ #i
    ==>
    (
        (Ex #r. Req(A, B, ltk, y) @ #r & r < i)
      | (Ex #k. LtkReveal(ltk) @ #k & k < i )
    )
    "

end
